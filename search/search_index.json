{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyShell","text":""},{"location":"#what-is-pyshell","title":"What is PyShell?","text":"<p>PyShell is a Python library designed to help developers create shell scripts. At its most basic, PyShell can be thought of as a wrapper around <code>subprocess.run()</code> that allows IDEs to display autocompletion help for commands. However, PyShell is much more than a basic wrapper and offers many features that greatly improve development workflows.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Looking to use PyShell to write your own shell scripts? Take a look at   PyShell's Sample Scripts and learn about PyShell's   components via the Usage section of PyShell's docs.</li> <li>Want to know what PyShell is capable of? Check out the Features   page.</li> <li>Wondering why PyShell was created? The Motivation page   explains the reasoning behind PyShell's design.</li> <li>Interested in contributing to PyShell? Read PyShell's   Contributing Guide and the Develop section of   PyShell's docs.</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Cross platform support*</li> <li>Command autocompletion</li> <li>Automatic logging to files</li> <li>Error handling</li> <li>Automatic validation</li> <li>Asynchronous commands</li> <li>Docker container support</li> </ul> <p>* As a Python library, PyShell is inherently cross platform. However, PyShell is currently only tested on Linux and a few of the shell commands invoke unix commands. If running on Windows, the current recommendation is to have Git for Windows installed and have its <code>bin</code> directory added to your <code>PATH</code>. This will ensure that all PyShell commands function as expected.</p>"},{"location":"#installation","title":"Installation","text":"<p>Currently, PyShell is not available on PyPI. To install PyShell, clone the repository or add it as a submodule, then configure your <code>PYTHONPATH</code> to include the <code>source</code> directory in the PyShell repository. PyShell will be added to PyPI once it is ready for a stable release.</p>"},{"location":"#platform-support","title":"Platform Support","text":"<p>PyShell is designed to be cross platform and will be usable on Linux, Windows, and macOS. However, PyShell has only been tested on Linux so far and requires a few changes before it will be usable on Windows. Support for Windows will be added in a future release as PyShell is developed further.</p>"},{"location":"#license","title":"License","text":"<p>PyShell is licensed under the MIT license.</p>"},{"location":"motivation/","title":"Motivation","text":""},{"location":"motivation/#shell-scripts","title":"Shell Scripts","text":"<p>PyShell was born out of a desire to unify platform specific shell scripts into a single script with a uniform feature set regardless of OS. For example, bash offers the <code>set -e</code> command to abort a script as soon as a script command fails: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\nls /foo # &lt;&lt;&lt; The script will exit here if /foo doesn't exist\necho \"This will not be printed.\"\n</code></pre></p> <p>But Batch does not offer an equivalent feature, instead requiring developers to write multiple extra lines to accomplish the same functionality: error.bat<pre><code>dir \"C:\\foo\"\nif errorlevel 1 (\nexit /b 1\n)\n</code></pre></p> <p>Using two different shell scripting languages also requires developers to be familiar with both languages. Even so, it's extremely easy to inadvertently introduce small differences in behavior, such as when using the <code>echo</code> command: echo.sh<pre><code>#!/usr/bin/env bash\necho \"foo\"\n# Output:\nfoo\n</code></pre> echo.bat<pre><code>@echo off\necho \"foo\"\nREM Output:\n\"foo\"\n</code></pre></p> <p>Standard out-of-the-box python fares better in regards to standardization between platforms, but suffers when running commands: cmake.sh<pre><code>#!/usr/bin/env bash\nset -e\n\n# Run CMake's configure step\ncmake -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=_out\n\n# Build the project\ncmake --build _build --target install\n</code></pre> cmake.bat<pre><code>@echo off\n\nREM Run CMake's configure step\ncmake.exe -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=_out\nif errorlevel 1 (\nexit /b\n)\nREM Build the project\ncmake.exe --build _build --target install\nif errorlevel 1 (\nexit /b\n)\n</code></pre> cmake.py<pre><code>#!/usr/bin/env python3\nimport subprocess\n# Run CMake's configure step\nsubprocess.run(\n[\n\"cmake\",\n\"-S\",\n\".\",\n\"-B\",\n\"_build\",\n\"-DCMAKE_BUILD_TYPE=Debug\",\n\"-DCMAKE_INSTALL_PREFIX=_out\"\n],\ncheck=True\n)\n# Run CMake's build step\nsubprocess.run(\n[\"cmake\", \"--build\", \"_build\", \"--target\", \"install\"],\ncheck=True\n)\n</code></pre></p> <p>This is where PyShell and its built in modules come into play. Using PyShell's CMake module, that <code>cmake.py</code> script could be written this way instead: cmake.py<pre><code>from pyshell import PyShell, AbortOnFailure\nfrom pyshell.modules import CMake, ECMakeBuildType\npyshell = PyShell(error_handler=AbortOnFailure())\n# Named function arguments shown for clarity only\nCMake.configure(\nsource=\".\",\nbuild=\"_build\",\ninstall=\"_out\",\nbuild_type=ECMakeBuildType.Debug\n)\nCMake.build(\nbuild=\"_build\",\ntarget=\"install\"\n)\n</code></pre> Without the named function arguments, the script is almost on par with the bash script: cmake.py<pre><code>from pyshell import PyShell, AbortOnFailure\nfrom pyshell.modules import CMake, ECMakeBuildType\npyshell = PyShell(error_handler=AbortOnFailure())\n# Run CMake's configure step\nCMake.configure(\".\", \"_build\", \"_out\", ECMakeBuildType.Debug)\n# Run CMake's build step\nCMake.build(\"_build\", \"install\")\n</code></pre></p> <p>Warning</p> <p>PyShell's CMake module has not been released yet. You may also want to consider making use of PyShell's sibling project, PyMake! PyMake is to CMake as PyShell is to shell scripts.</p> <p>Unlike the previous python script, the PyShell-based script is much more strongly typed. When writing the PyShell script, developers don't have to remember the exact flags that CMake requires for setting its source directory or build type since IDEs can display the method's parameters to developers. PyShell will also do additional validation when the script runs, such as verifying that the CMake executable can be found.</p>"},{"location":"motivation/#error-handling","title":"Error Handling","text":"<p>Though PyShell's foundation was rooted in using Python for shell scripts, PyShell has grown into much more. PyShell shines particularly bright when it comes to error handling, where PyShell scripts have significant improvements over their batch/bash counterparts.</p> <p>For example, consider this bash script: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\necho \"before failed command\"\nls /foo/bar\necho \"after failed command\"\necho \"perform cleanup\"\n</code></pre></p> <p>The output of that script is: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./error.sh\nbefore failed command\nls: cannot access '/foo/bar': No such file or directory\n</code></pre></p> <p>This script is just a toy script, but imagine if the script's cleanup command had to run something more important. What if the cleanup command was one that corrected file permissions on a CI/CD system, and now every subsequent CI/CD run on that machine will now fail? That's obviously no good, so the script clearly must be adjusted to handle that. There's more than one way to go about this, such as: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\necho \"before failed command\"\nif ! ls /foo/bar; then\necho \"error\"\nfi\necho \"after failed command\"\necho \"perform cleanup\"\n</code></pre></p> <p>The updated script's output: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./error.sh\nbefore failed command\nls: cannot access '/foo/bar': No such file or directory\nerror\nafter failed command\nperform cleanup\n</code></pre></p> <p>This is better, but now there's a different problem. If the \"after failed command\" command is only valid to be executed if the failing command finished successfully, then now the script will now terminate on that line instead. That command could be moved into the if statement, but a real script may have many lines between the two commands or many dependent commands. Alternatively, the cleanup code could be moved into its own function: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\ncleanup() {\necho \"perform cleanup\"\nexit $1\n}\necho \"before failed command\"\nls /foo/bar || cleanup 1\necho \"after failed command\" || cleanup 1\ncleanup 0\n</code></pre></p> <p>Output: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./error.sh\nbefore failed command\nls: cannot access '/foo/bar': No such file or directory\nperform cleanup\n</code></pre></p> <p>That's a significant improvement, but PyShell can do even better: error.py<pre><code>#!/usr/bin/env python3\nfrom pyshell import PyShell, KeepGoing, PermitCleanup, CommandFlags\nfrom pyshell.modules import Shell\npyshell = PyShell(\nexecutor=PermitCleanup(),\nerror_handler=KeepGoing()\n)\n# No commands have failed, so this command will be run\nShell.echo(\"before failed command\")\n# This command will fail, but the error handler will ignore it because the\n#   error handler is set to `KeepGoing`\nShell.ls(\"/foo/bar\")\n# This command won't run because it's a standard command\nShell.echo(\"after failed command\")\n# This command will run because it's a cleanup command\nShell.echo(\"perform cleanup\", cmd_flags=CommandFlags.CLEANUP)\n</code></pre></p> <p>Output: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./sample.py\nbefore failed command\n/usr/bin/ls: cannot access '/foo/bar': No such file or directory\nCommand '/usr/bin/ls' failed with exit code 2.\nNote: Full command was '/usr/bin/ls /foo/bar'.\nperform cleanup\n</code></pre></p> <p>This example introduces a new PyShell concept, the executor. This is a component that decides whether a command is allowed to execute. In this example, the <code>PermitCleanup</code> executor is used along with the <code>KeepGoing</code> error handler. This is necessary to avoid stopping the script immediately upon a command failing, which is what would happen if the script had used the <code>AbortOnFailure</code> error handler. The <code>KeepGoing</code> error handler also isn't usable on its own in this scenario, as otherwise it would allow the \"after failed command\" echo command to be executed.</p> <p>Instead, the combination of the <code>PermitCleanup</code> executor and the <code>KeepGoing</code> error handler ensures that all commands after the failed command do not execute... except cleanup commands. By using these two PyShell components, the script can be written with a linear structure that does not require the reader to jump to the cleanup method to discover what the script runs.</p>"},{"location":"motivation/#logging","title":"Logging","text":"<p>PyShell was designed with a heavy emphasis on logging, resulting in a number of features that assist developers in processing log files generated by a script. PyShell defaults to only writing information to the console, but its behavior can be easily adjusted to also write to log files on disk while also printing to the console. For example, PyShell offers the <code>SingleFileLogger</code> and <code>MultiFileLogger</code> classes, which are used in the \"Hello World\" sample script: hello_world.py<pre><code>#!/usr/bin/env python3\nimport argparse\nfrom pyshell import PyShell, NullFileLogger, SingleFileLogger, MultiFileLogger\nfrom pyshell.modules import Shell\n# Decide whether to log to a single file or multiple files\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--log\", choices=[\"single\", \"multi\"], default=None)\nargs = parser.parse_args()\nif args.log == \"single\":\nlogger = SingleFileLogger(\"hello_world.log\")\nelif args.log == \"multi\":\nlogger = MultiFileLogger(\n\".logs\",\nprint_cmd_header=True,\nprint_cmd_footer=True\n)\nelse:\nlogger = NullFileLogger()\n# Initialize a PyShell instance for running commands\n# PyShell commands that don't explicitly specify a PyShell instance to use\n#   will use the default instance.\npyshell = PyShell(logger=logger)\n# Run some commands\nShell.echo(\"Hello, world!\")\nShell.echo(\"Hello world again!\")\nShell.echo(\"Howdy y'all!\")\n</code></pre></p> <p>When the <code>NullFileLogger</code> class is used, the only output from the script is to the console: <pre><code>pyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ./hello_world.py Hello, world!\nHello world again!\nHowdy y'all!\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ll\ntotal 12\ndrwxr-xr-x 2 pyshell pyshell 4096 Feb 27 02:55 ./\ndrwxrwxr-x 3 pyshell pyshell 4096 Feb 23 20:52 ../\n-rwxr-xr-x 1 pyshell pyshell  903 Feb 27 02:54 hello_world.py*\n</code></pre></p> <p>If the <code>--log single</code> flag is provided, output will be written to both the console and a log file on disk: <pre><code>pyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ./hello_world.py --log single\nHello, world!\nHello world again!\nHowdy y'all!\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ll\ntotal 16\ndrwxr-xr-x 2 pyshell pyshell 4096 Feb 27 02:56 ./\ndrwxrwxr-x 3 pyshell pyshell 4096 Feb 23 20:52 ../\n-rw-r--r-- 1 pyshell pyshell   49 Feb 27 02:56 hello_world.log\n-rwxr-xr-x 1 pyshell pyshell  903 Feb 27 02:54 hello_world.py*\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ cat hello_world.log\nHello, world!\nHello world again!\nHowdy y'all!\n</code></pre></p> <p>Alternatively, if <code>--log multi</code> is used, each command's output is written to its own file: <pre><code>pyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ./hello_world.py --log multi\nHello, world!\nHello world again!\nHowdy y'all!\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ll\ntotal 16\ndrwxr-xr-x 3 pyshell pyshell 4096 Feb 27 02:57 ./\ndrwxrwxr-x 3 pyshell pyshell 4096 Feb 23 20:52 ../\ndrwxr-xr-x 2 pyshell pyshell 4096 Feb 27 02:57 .logs/\n-rwxr-xr-x 1 pyshell pyshell  903 Feb 27 02:54 hello_world.py*\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ll .logs\ntotal 20\ndrwxr-xr-x 2 pyshell pyshell 4096 Feb 27 02:57 ./\ndrwxr-xr-x 3 pyshell pyshell 4096 Feb 27 02:57 ../\n-rw-r--r-- 1 pyshell pyshell  306 Feb 27 02:57 1-echo.log\n-rw-r--r-- 1 pyshell pyshell  321 Feb 27 02:57 2-echo.log\n-rw-r--r-- 1 pyshell pyshell  303 Feb 27 02:57 3-echo.log\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ cat .logs/1-echo.log [PyShell] Running command: /usr/bin/echo Hello, world!\n[PyShell] cwd: /workspaces/PyShell/samples/1-hello-world\n[PyShell] Command output:\nHello, world!\n[PyShell] Executed command: /usr/bin/echo Hello, world!\n[PyShell] cwd: /workspaces/PyShell/samples/1-hello-world\n[PyShell] Command exited with code 0.\n</code></pre></p> <p>Visible in the multi-file logger example are PyShell's optional header and footer sections. These sections are enabled by passing these arguments to the multi-file logger's constructor: <pre><code>logger = MultiFileLogger(\n\".logs\",\nprint_cmd_header=True, # &lt;&lt;&lt;\nprint_cmd_footer=True  # &lt;&lt;&lt;\n)\n</code></pre></p> <p>Info</p> <p>These parameters are also supported by the <code>SingleFileLogger</code> class's constructor.</p> <p>PyShell also allows a scanner class to be attached to commands, which enables PyShell to output extra information to help developers. This is particularly helpful when dealing with long log files that would otherwise require developers to scroll through the log to find what they're looking for.</p> <p>For example, PyShell's <code>generate_docs.py</code> script invokes Doxygen and generates a ~500 line file. Should the command fail, such as due to a parameter lacking documentation, the <code>generate_docs.py</code> script will stop and report an error. A developer would then need to scroll through the log file generated for the Doxygen command, find the error message from Doxygen, then open the file and fix the issue. With PyShell's Doxygen scanner however, the bottom of the log file contains all the information necessary to fix the issue: doxygen.log<pre><code>Patching output file 34/36\nPatching output file 35/36\nPatching output file 36/36\nlookup cache used 645/65536 hits=1314 misses=768\nfinished...\nExiting...\n[PyShell] Scanner output:\n[PyShell] Missing parameter documentation for:\n[PyShell]   File: /workspaces/PyShell/source/pyshell/core/command_metadata.py:15\n[PyShell]   Method: pyshell.core.command_metadata.CommandMetadata.__init__(self, str command, Sequence[str] args, CommandFlags flags=CommandFlags.STANDARD, Optional[IScanner] scanner=None)\n[PyShell]   Parameter: scanner\n[PyShell] Missing parameter documentation for:\n[PyShell]   File: /workspaces/PyShell/source/pyshell/doxygen/doxygen_scanner.py:81\n[PyShell]   Method: pyshell.doxygen.doxygen_scanner.DoxygenScanner._generate_missing_parameter_entry(self, CommandResult result, str line, List[str] next_lines, int line_number)\n[PyShell]   Parameter: result\n[PyShell] Executed command: /usr/bin/doxygen /workspaces/PyShell/doxygen/doxyfile\n[PyShell] cwd: /workspaces/PyShell\n[PyShell] Command exited with code 1.\n</code></pre></p> <p>Though scanners are nothing complex, their addition to PyShell is a solid quality of life addition for developers.</p>"},{"location":"develop/contributing/","title":"Contributing Guide","text":""},{"location":"develop/contributing/#getting-started","title":"Getting Started","text":"<p>PyShell's repository is set up with support for VSCode's devcontainers. This is the recommended workflow when developing PyShell as it ensures that all dependencies are installed and configured correctly. If you are not using VSCode, take a look at the <code>.devcontainer/ubuntu.dockerfile</code> file to see what dependencies are required to develop PyShell. Please note that the <code>.devcontainer/devcontainer.json</code> file also has a few other values that you may need, such as environment variables that are set within the container.</p>"},{"location":"develop/contributing/#general-guidelines","title":"General Guidelines","text":"<p>Please keep the following guidelines in mind when contributing to PyShell:</p> <ul> <li>Type hints must be provided on all methods and variables.</li> </ul> <p>For methods, all method parameters must have type hints. The return value must have a type hint if it is not <code>None</code>. Variables must have type hints if their type cannot be inferred from the value.</p> <ul> <li>All code must use Doxygen style comments.</li> </ul> <p>PyShell uses Doxygen to generate its reference documentation. All methods and parameters must have a Doxygen comment block, and Doxygen is configured to flag missing documentation as an error. Member variables should have explicit documentation unless they're directly assigned from constructor parameters, in which case the constructor parameter documentation will suffice.</p> <p>For more information on how to use Doxygen and what commands it offers, see the Doxygen documentation.</p> <p>Note</p> <p>Although Doxygen is configured to flag missing documentation as an error, some documentation elements do not get flagged by Doxygen. For example, it is not necessary to add <code>@returns</code> to an <code>@property</code> method despite it technically being a method.</p>"},{"location":"develop/contributing/#adding-new-commands","title":"Adding New Commands","text":"<p>Commands and modules are an area in which contributions are most welcome. Adding a new command or module is a great way to get started with PyShell development as it does not require a deep understanding of the internals of PyShell.</p> <p>To add a new command, you will need to define a new class that inherits from either <code>ICommand</code> or <code>ExternalCommand</code>. The <code>ICommand</code> class is an abstract base class that should only be used if the <code>ExternalCommand</code> class is unsuitable for your new custom command. Otherwise, you should use the <code>ExternalCommand</code> class as it provides a lot of functionality that is common to most commands.</p> <p>You can find the <code>ICommand</code> class's definition here and the <code>ExternalClass</code>'s definition here. The <code>ls</code> command and <code>cp</code> command are good examples of how to use the <code>ExternalCommand</code> class as a base class.</p> <p>Here are some guidelines to keep in mind when adding a new command:</p> <ul> <li>The command's constructor should take a <code>CommandFlags</code> parameter.</li> <li>Avoid throwing exceptions. Instead, return a <code>CommandResult</code> object with the   <code>success</code> property set to <code>False</code> when the command is executed. This ensures   that all commands use the PyShell instance's error handling mechanism.</li> </ul> <p>Following these guidelines will ensure that your command behaves consistently with other commands.</p>"},{"location":"develop/contributing/#adding-new-modules","title":"Adding New Modules","text":"<p>Once you've implemented a new command(s), it's highly recommended that you also implement a module for the commands. A module is a loose wrapper around a set of related commands that allows each command to be executed in a single method call instead of two method calls. An example of this is the <code>Shell</code> module, which can be found here.</p> <p>Here are some guidelines to keep in mind when adding a new module:</p> <ul> <li>Each method in the module should take the same parameters as the underlying   command's constructor, plus an additional <code>PyShell</code> parameter to be passed to   the command when executing it. Parameters should be specified in the same   order in the module as in the command.</li> </ul>"},{"location":"develop/features/","title":"Features","text":""},{"location":"develop/features/#pyshell-features","title":"PyShell Features","text":"<ul> <li>Cross platform support</li> </ul> <p>Warning</p> <p>PyShell is currently only tested on Linux and a few of the shell commands invoke Linux commands. If using PyShell on Windows, it is highly recommended to have Git for Windows installed and have its <code>bin</code> directory added to your <code>PATH</code>. This will ensure that all PyShell commands function as expected.</p> <p>PyShell scripts are standard python scripts and can be run on any platform that Python supports. Built-in PyShell modules are designed to be cross platform, so PyShell-based scripts generally do not need to branch by OS. By writing scripts using PyShell, you'll no longer need to write bash and batch scripts that are functionally identical.</p> <ul> <li>Command autocompletion</li> </ul> <p>The built-in PyShell modules allow shell commands and external executables to be invoked as Python methods. This allows IDEs to present information about the parameters that the method accepts instead of forcing developers to try and remember exactly what flag it was that does what you need.</p> <ul> <li>Automatic logging to files</li> </ul> <p>Using PyShell's built in logger classes, you can choose how you want to log your script's output. For example, you can configure PyShell to tee all output from commands executed by your script to a single file, or you can choose to write each command's output to a different file. Logging configuration is handled when you initialize a <code>PyShell</code> class instance and does not need to be handled on a per-command basis.</p> <ul> <li>Error handling</li> </ul> <p>PyShell gives scripts a lot of control over how they want to handle errors. Basic scripts may simply want to abort script execution upon encountering an error, while other scripts may want to continue executing certain commands such as cleanup commands. PyShell provides built-in classes that make it easy to implement proper error handling in scripts.</p> <ul> <li>Automatic validation</li> </ul> <p>It's all too easy to write scripts that assume certain conditions are true and end up erroring out far away from where the invalid assumption is located. PyShell commands automatically validate their input and any external state required to run the command when the command instance is constructed, allowing errors to be detected as early as possible.</p> <ul> <li>Asynchronous commands</li> </ul> <p>PyShell commands can run synchronously or asynchronously. This allows scripts to run multiple commands at the same time, providing significant speed ups for long-running scripts. An async command returns a standard command result object and will only block the script once result properties are accessed.</p> <ul> <li>Docker container support</li> </ul> <p>PyShell instances can be configured to target a docker container instead of running commands on the host system. This means that a PyShell script can execute commands on the host system as well as within a docker container - all from a single script and with a non-branching code path.</p>"},{"location":"develop/roadmap/","title":"Roadmap","text":"<p>Warning</p> <p>All features listed here are subject to change. Features will be implemented on an as-needed basis to support other projects.</p> <ul> <li>Windows support</li> </ul> <p>This will be the next feature to be implemented. PyShell is intended to be cross platform, but a few of the shell commands need to be updated to invoke the correct Windows commands instead of assuming that the host system is Linux. Also, PyShell's CI/CD pipeline will need to be updated to run tests on Windows.</p> <ul> <li>SSH support</li> </ul> <p>PyShell is already capable of running commands on a not-host machine by way of invoking commands in a docker container. An <code>SshBackend</code> class will be added in the future to allow PyShell to run commands on a remote machine via SSH.</p> <ul> <li>MultiSSH support</li> </ul> <p>A new <code>PyShell</code>-style class will be added that allows commands to be run on multiple targets at the same time. This will be used to implement a <code>MultiSshBackend</code> that allows the same commands to be run on multiple remote machines at the same time.</p> <ul> <li>Per-invocation overrides</li> </ul> <p>With PyShell's split between when a command is defined and when it is invoked, it would be possible to add support for overriding components or parameters when a command is invoked. This would allow a command to be defined once and then reused with different parameters or components; for example, a PyShell instance could be configured to use the <code>ConsoleLogger</code> class, but a singular command in the script could be configured to use the <code>SingleFileLogger</code> class instead.</p>"},{"location":"learn/quickstart/","title":"Quickstart","text":""},{"location":"learn/quickstart/#overview","title":"Overview","text":"<p>This page's intended audience is experienced PyShell developers who simply need to quickly look up how to perform a task in PyShell. New developers are recommended to browse through the other PyShell documentation pages to gain a familiarity with PyShell before making use of this page.</p>"},{"location":"learn/sample-scripts/","title":"Sample Scripts","text":""},{"location":"learn/sample-scripts/#overview","title":"Overview","text":"<p>Several sample scripts are provided as part of the PyShell repository to demonstrate the use of the PyShell framework. These scripts are located in the <code>samples</code> directory of the repository. For more information on each script, see below.</p>"},{"location":"learn/sample-scripts/#1-hello_worldpy","title":"1. <code>hello_world.py</code>","text":"<p>This script demonstrates the basic usage of the PyShell framework. It implements a simple shell that prints several messages using the <code>Shell</code> module's <code>echo()</code> method, then exits. The script can be found here.</p> <p>This script may be invoked with no arguments, which will cause the script to print its messages to the console. Alternatively, the script may be invoked with the argument <code>--log single</code> or <code>--log multi</code>, which will cause the script to print its messages to a single log file or multiple log files, respectively. The script also supports three verbosity levels, which determine whether no extra output is printed, only command headers are printed, or command headers and footers are printed. By default, no extra output is printed. Printing command headers can be enabled by passing <code>-v</code> or <code>--verbose</code> as an argument, while printing command footers can be enabled by passing <code>-vv</code> or by passing <code>--verbose</code> twice.</p>"},{"location":"learn/sample-scripts/#2-docker_hello_worldpy","title":"2. <code>docker_hello_world.py</code>","text":"<p>This script demonstrates the use of the PyShell framework to execute Docker commands. It first prints multiple commands on the host using the <code>Shell</code> module's <code>echo()</code> method, then starts a docker container. The messages are then repeated inside the container, then the container is stopped and removed. Lastly, the script repeats the commands on the host again. The script can be found here.</p> <p>This script supports the same arguments as the <code>hello_world.py</code> script.</p>"},{"location":"usage/commands/","title":"PyShell Commands","text":""},{"location":"usage/commands/#overview","title":"Overview","text":"<p>PyShell commands are classes that execute a specific task. Most PyShell commands map one to one with a command line tool, though this is not a requirement. All commands execute by invoking an external command or executable, which allows PyShell to capture the command's output and log it using the PyShell instance's configured logger. PyShell commands may also perform extra validation and error handling, such as checking for the existence of a required executable.</p>"},{"location":"usage/commands/#general-usage","title":"General Usage","text":"<p>For most scripts, commands will be invoked via modules. However, commands may also be explicitly constructed and invoked, which allows a command's invocation to be separate from where it is defined.</p> <p>In general, command classes will define constructor parameters corresponding to the most command command flags and options. These parameters are used to construct the command's command line arguments. For example, the <code>ls</code> command defines an optional <code>target_path</code> parameter, which is passed to <code>ls</code> if it's provided: <pre><code>from pyshell.shell.ls_command import LsCommand\n# Set up a PyShell instance\n# ...\n# Invoke `ls` with no arguments\ncmd1 = LsCommand()\ncmd1()\n# Invoke `ls` with the argument `/tmp`\ncmd2 = LsCommand('/tmp')\ncmd2()\n# Invoke `ls` with the argument `/home`\ncmd3 = LsCommand(target_path='/home')\ncmd3()\n</code></pre></p> <p>The purpose of commands is to provide stricter type checking for command parameters and to enable IDEs to suggest parameters that may be passed to a command. This is especially evident when using Docker commands, which frequently require a large number of parameters. For example, the <code>docker run</code> command accepts more than 10 parameters in its constructor. Rather than needing to remember whether specifying ports is done using <code>--ports</code> or <code>--publish</code>, a developer simply needs to look at their IDE's suggestions for the run command's constructor. Each constructor parameter is also strongly typed where possible, reducing the likelihood of a developer passing an invalid value.</p>"},{"location":"usage/commands/#flags","title":"Flags","text":"<p>PyShell-specific flags may be specified when constructing a command, which is passed in via the <code>cmd_flags</code> parameter for most command classes. These flags are most frequently used to prevent a command from executing by marking it as inactive, ensuring that a command is always run by marking it as a cleanup command, or to modify how the command's output is logged. The full set of flags can be found here.</p> <p>Command flags may also be dynamically set using a custom condition or by checking if another command has failed. For example, the following command will only execute if the <code>ls</code> command fails: <pre><code>from pyshell import enable_if\nfrom pyshell.shell.ls_command import LsCommand\n# Set up a PyShell instance\n# ...\n# Invoke the `ls` command; assume that it fails\nresult = LsCommand()()\n# Invoke the `echo` command, but only if the `ls` command failed\ncmd = EchoCommand('Hello, world!', cmd_flags=enable_if(result.failed))\ncmd()\n</code></pre></p> <p>More information on the <code>enable_if</code> function can be found here.</p>"},{"location":"usage/commands/#custom-commands","title":"Custom Commands","text":"<p>There are an infinite number of commands that may be executed by a shell script, and commands frequently offer a large number of flags. While PyShell provides a large number of commands out of the box, it is not possible to provide a command for every possible use case. To address this, PyShell provides an <code>ExternalCommand</code> class that may be used directly from within a PyShell script to execute a command while still taking advantage of PyShell's logging and error handling.</p> <p>The <code>ExternalCommand</code> class may be used like this: <pre><code>from pyshell.commands.external_command import ExternalCommand\n# Set up a PyShell instance\n# ...\n# Invoke `ls` with no arguments\ncmd1 = ExternalCommand('ls')\ncmd1()\n# Invoke `ls` with the argument `/tmp`\ncmd2 = ExternalCommand('ls', '/tmp')\ncmd2()\n# Invoke `ls` with the argument `/tmp` and the flag `--all`\ncmd3 = ExternalCommand('ls', ['/tmp', '--all'])\ncmd3()\n# Invoke `ls` and silence its output\ncmd4 = ExternalCommand('ls', cmd_flags=CommandFlags.QUIET)\ncmd4()\n</code></pre></p>"},{"location":"usage/components/","title":"PyShell Components","text":""},{"location":"usage/components/#pyshell-class","title":"<code>PyShell</code> Class","text":"<p>All PyShell-based scripts will need to instantiate one or more instances of the <code>PyShell</code> class. This class acts as a wrapper for the various components that determine how PyShell executes commands, how the commands' output is logged, and how errors are handled.</p> <p>To use the PyShell class, import it using: <pre><code>from pyshell import PyShell\n</code></pre></p> <p>To get started immediately with PyShell, simply instantiate a new instance of the class: <pre><code>pyshell = PyShell()\n</code></pre></p> <p>A default-constructed PyShell instance will be approximately equivalent to a bash script that specifies <code>set -e</code> at the start of the script. To customize this behavior, pass different components to the PyShell constructor. For example, using the <code>SingleFileLogger</code> component instead of the default <code>ConsoleLogger</code> component will cause all commands' output to be written to a file in addition to being displayed in the console's output: <pre><code>from pyshell import PyShell, SingleFileLogger\npyshell = PyShell(logger=SingleFileLogger(\"output.log\"))\n</code></pre></p> <p>Each component that may be passed to the PyShell constructor is documented in more detail below.</p>"},{"location":"usage/components/#backends","title":"Backends","text":"<p>PyShell supports three different backends. The <code>NativeBackend</code> is the default, and will run commands on the host machine much like a standard shell script. The <code>DryRunBackend</code> class will print all commands that it would run but will not run any of the commands. Lastly, the <code>DockerBackend</code> will start a docker container and execute all commands within the docker container.</p>"},{"location":"usage/components/#native-backend","title":"Native Backend","text":"<p>The native backend is the default backend and is used when a <code>PyShell</code> instance is instantiated without specifying a backend. The native backend will execute commands on the host machine.</p> <p>You can configure a PyShell instance to use the native backend using either of the following: <pre><code>from pyshell import PyShell\npyshell = PyShell()\n</code></pre> <pre><code>from pyshell import PyShell, NativeBackend\npyshell = PyShell(backend=NativeBackend())\n</code></pre></p>"},{"location":"usage/components/#dry-run-backend","title":"Dry Run Backend","text":"<p>The dry run backend will print all commands that it would run but will not run any of the commands. This is useful for debugging scripts or for testing scripts without actually running them.</p> <p>You can configure a PyShell instance to use the dry run backend using: <pre><code>from pyshell import PyShell, DryRunBackend\npyshell = PyShell(backend=DryRunBackend())\n</code></pre></p>"},{"location":"usage/components/#docker-backend","title":"Docker Backend","text":"<p>The docker backend will start a docker container and execute all commands within the docker container. This is useful for writing scripts that run on a host machine but need to execute some or all commands within a docker container. To use the docker backend, you must specify the docker image that you want to use when instantiating the backend:</p> <pre><code>from pyshell import PyShell, DockerBackend\nbackend = DockerBackend(\"ubuntu:latest\")\npyshell = PyShell(backend=backend)\n# ...\nbackend.stop()\n</code></pre> <p>Note that unlike the other backends, the docker backend must be explicitly stopped using the <code>stop()</code> method. This will ensure that the docker container is stopped and removed. However, when debugging a script, it may be useful to comment out the <code>stop()</code> call so that you can inspect the docker container after the script has finished executing.</p> <p>For more information on how to use the docker backend, see the Docker backend's documentation, found here.</p>"},{"location":"usage/components/#loggers","title":"Loggers","text":"<p>Loggers determine how the output of commands are logged. By default, PyShell uses the <code>ConsoleLogger</code> class to log commands' output, which writes all output to the console. PyShell also ships with several other loggers that may be used out of the box.</p>"},{"location":"usage/components/#console-logger","title":"Console Logger","text":"<p>The console logger is the default logger and is used when a <code>PyShell</code> instance is instantiated without specifying a logger. The console logger will write all commands' output to the console.</p> <p>You can configure a PyShell instance to use the console logger using either of the following: <pre><code>from pyshell import PyShell\npyshell = PyShell()\n</code></pre> <pre><code>from pyshell import PyShell, ConsoleLogger\npyshell = PyShell(logger=ConsoleLogger())\n</code></pre></p> <p>More information on the console logger can be found in the console logger's documentation, found here.</p>"},{"location":"usage/components/#single-file-logger","title":"Single File Logger","text":"<p>The single file logger will write all commands' output to a single file in addition to the console. This logger is approximately equivalent to piping all commands' output to a file using <code>| tee -a output.log</code>.</p> <p>To use the single file logger, you must specify the path to the file that you want to write to when instantiating the logger: <pre><code>from pyshell import PyShell, SingleFileLogger\npyshell = PyShell(logger=SingleFileLogger(\"output.log\"))\n</code></pre></p> <p>More information on the single file logger can be found in the single file logger's documentation, found here.</p>"},{"location":"usage/components/#multi-file-logger","title":"Multi File Logger","text":"<p>The multi file logger will write all commands' output to a separate file for each command. This logger is approximately equivalent to piping each command's output to a separate file using <code>| tee cmd.log</code>. Using the multi file logger has multiple benefits over emulating the same behavior using <code>tee</code>; for example, the multi file logger will automatically create a new file for each command and will automatically assign the file a name based on the command's name and number of commands that have been run. For example, if a script runs <code>echo</code>, then <code>rm</code>, then <code>ls</code>, the logger will create three files:</p> <ul> <li><code>1-echo.log</code> - contains the output of the <code>echo</code> command</li> <li><code>2-rm.log</code> - contains the output of the <code>rm</code> command</li> <li><code>3-ls.log</code> - contains the output of the <code>ls</code> command</li> </ul> <p>To use the multi file logger, you must specify the path to the directory that you want to write the files to when instantiating the logger: <pre><code>from pyshell import PyShell, MultiFileLogger\npyshell = PyShell(logger=MultiFileLogger(\"logs\"))\n</code></pre></p> <p>More information on the multi file logger can be found in the multi file logger's documentation, found here.</p>"},{"location":"usage/components/#null-logger","title":"Null Logger","text":"<p>The null logger will not log any commands' output and is equivalent to piping all commands' output to <code>/dev/null</code>.</p> <p>You can configure a PyShell instance to use the null logger using: <pre><code>from pyshell import PyShell, NullLogger\npyshell = PyShell(logger=NullLogger())\n</code></pre></p> <p>More information on the null logger can be found in the null logger's documentation, found here.</p>"},{"location":"usage/components/#executors","title":"Executors","text":"<p>PyShell's executor component determines whether a command is allowed to execute. By default, PyShell uses the <code>AllowAll</code> executor, which allows all non-inactive commands to be run. PyShell also ships with a <code>PermitCleanup</code> executor that blocks execution of non-cleanup commands after a failure has occurred.</p>"},{"location":"usage/components/#allow-all-executor","title":"Allow All Executor","text":"<p>The allow all executor is the default executor and is used when a <code>PyShell</code> instance is instantiated without specifying an executor. The allow all executor will allow all non-inactive commands to be run regardless of whether a failure has occurred.</p> <p>You can configure a PyShell instance to use the allow all executor using either of the following: <pre><code>from pyshell import PyShell\npyshell = PyShell()\n</code></pre> <pre><code>from pyshell import PyShell, AllowAll\npyshell = PyShell(executor=AllowAll())\n</code></pre></p> <p>More information on the allow all executor can be found in the allow all executor's documentation, found here.</p>"},{"location":"usage/components/#permit-cleanup-executor","title":"Permit Cleanup Executor","text":"<p>The permit cleanup executor will block execution of non-cleanup commands after a failure has occurred. This executor is useful for writing scripts that need to perform cleanup tasks after a failure has occurred. For example, if a script needs to remove a file after a failure has occurred, the script can use the permit cleanup executor to ensure that the file is removed even if the script fails.</p> <p>To use the permit cleanup executor, you must specify the path to the file that you want to write to when instantiating the logger: <pre><code>from pyshell import PyShell, PermitCleanup\npyshell = PyShell(executor=PermitCleanup())\n</code></pre></p> <p>More information on the permit cleanup executor can be found in the permit cleanup executor's documentation, found here.</p>"},{"location":"usage/components/#error-handlers","title":"Error Handlers","text":"<p>PyShell's error handler component determines how a command's failure is handled. Error handlers are closely related to executors; the difference is that error handlers are called after a command has failed, whereas executors are called before a command is run. By default, PyShell uses the <code>AbortOnFailure</code> error handler, which will abort the script if a command fails. PyShell also ships with a <code>KeepGoing</code> error handler that will continue executing the script after a command has failed.</p>"},{"location":"usage/components/#abort-on-failure-error-handler","title":"Abort On Failure Error Handler","text":"<p>The abort on failure error handler is the default error handler and is used when a <code>PyShell</code> instance is instantiated without specifying an error handler. The abort on failure error handler will cause a script to be immediately aborted if a command fails. This error handler is equivalent to using the <code>set -e</code> option in bash.</p> <p>You can configure a PyShell instance to use the abort on failure error handler using either of the following: <pre><code>from pyshell import PyShell\npyshell = PyShell()\n</code></pre> <pre><code>from pyshell import PyShell, AbortOnFailure\npyshell = PyShell(error_handler=AbortOnFailure())\n</code></pre></p> <p>More information on the abort on failure error handler can be found in the abort on failure error handler's documentation, found here.</p>"},{"location":"usage/components/#keep-going-error-handler","title":"Keep Going Error Handler","text":"<p>The keep going error handler will continue executing the script after a command has failed. This error handler is equivalent to using the <code>set +e</code> option in bash. This error handler is useful for writing scripts that need to continue executing after a command has failed and is frequently used with the permit cleanup executor.</p> <p>You can configure a PyShell instance to use the keep going error handler using the following: <pre><code>from pyshell import PyShell, KeepGoing\npyshell = PyShell(error_handler=KeepGoing())\n</code></pre></p> <p>More information on the keep going error handler can be found in the keep going error handler's documentation, found here.</p>"},{"location":"usage/components/#configuration","title":"Configuration","text":"<p>PyShell also allows values to be specified for built in options. These options may be queried by PyShell commands to determine how they should behave. For example, you can enable verbose logging by setting the <code>verbose</code> option to <code>True</code>: <pre><code>from pyshell import PyShell, PyShellOptions\npyshell = PyShell(options=PyShellOptions(verbose=True))\n</code></pre></p> <p>Commands that support verbose output will check the shell's <code>verbose</code> option and enable verbose output if the option is set to <code>True</code>.</p> <p>More information on the built in options can be found in the <code>PyShellOptions</code> documentation, found here.</p>"},{"location":"usage/modules/","title":"PyShell Modules","text":""},{"location":"usage/modules/#overview","title":"Overview","text":"<p>PyShell modules are classes that define static methods for constructing and executing PyShell commands in a single method call. Modules are useful for organizing commands into logical groups, reducing the number of imports that need to be added to a script, and to quickly check what commands are available.</p> <p>For example, the <code>pyshell.modules.shell</code> module defines various frequently used commands, such as <code>ls</code>, <code>cp</code>, and <code>rm</code>. These commands are defined as static methods, allowing IDEs to suggest them when typing <code>Shell.</code>. Additionally, using the Shell module reduces the number of imports from: <pre><code>from pyshell.shell.cp_command import CpCommand\nfrom pyshell.shell.echo_command import EchoCommand\nfrom pyshell.shell.ls_command import LsCommand\nfrom pyshell.shell.rm_command import RmCommand\n# Set up a PyShell instance\n# ...\n# Invoke various shell commands\nLsCommand('/tmp')()\nEchoCommand('Hello, world!')()\nRmCommand('/tmp/foo')()\n</code></pre> To: <pre><code>from pyshell.modules.shell import Shell\n# Set up a PyShell instance\n# ...\n# Invoke various shell commands\nShell.ls('/tmp')\nShell.echo('Hello, world!')\nShell.rm('/tmp/foo')\n</code></pre></p> <p>PyShell currently ships with the following modules:</p> <ul> <li>Shell</li> <li>Doxygen</li> <li>Docker</li> </ul>"}]}